{
	// Place your ACM 工作区 snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	// "Print to console": {
	// 	"scope": "javascript,typescript",
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }

  // 代码转换网址：
  // https://snippet-generator.app/

"Create cpp": {
"prefix": "ccpp",
"body": [
	"#include<bits/stdc++.h>",
	"using namespace std;",
	"#define int long long",
	"#define endl \"\\n\"",
	"const int N = 1e6 + 10;",
	"const double eps =1e-4;",
	"const int mod1 = 998244353;",
	"",
	"//int a[N];",
	"//vll a;",
	"",
	"signed main(){",
	"    ios::sync_with_stdio(false);",
	"    cin.tie(nullptr);cout.tie(nullptr);",
	"    ",
	"    ",
	"    ",
	"    return 0;",
	"}"
],
"description": "初始格式化"
},
"bool cmp": {
"prefix": "bcmp",
"body": [
	"bool cmp(int a, int b){",
	"    return a > b;",
	"}"
],
"description": "bool cmp"
},
"快速幂": {
"body": [
	"int fastPower(int a, int b, int mod/* 取模 */) {",
	"    int result = 1; // 初始化结果为1",
	"    a = a % mod; // 将a对m取模",
	"    while (b > 0) {",
	"        // 如果b的当前位是1，则将当前的a乘到result上",
	"        if (b & 1) { // 等价于 if (b % 2 == 1)",
	"            result *= a;",
	"\t\t\tresult %= mod;",
	"        }",
	"        // 将a平方，准备处理下一位",
	"        a *= a;",
	"\t\ta %= mod;",
	"        // b右移一位",
	"        b >>= 1; // 等价于 b = b / 2;",
	"    }",
	"    return result;",
	"}"
],
"prefix": "ksm",
"description": "快速幂函数，计算 a^b % m"
},
"10进制转x进制": {
	"body": [
		"string ten_to_x_base(int n,int x){",
		"\tstack<char> s;",
		"\tstring xs;",
		"\twhile (n > 0) {",
		"\t\tint tmp = n % x;",
		"\t\tif (tmp >= 10) {",
		"\t\t\ts.push('A' + tmp - 10);",
		"\t\t}",
		"\t\telse {",
		"\t\t\ts.push('0' + tmp - 0);",
		"\t\t}",
		"\t\tn /= x;",
		"\t}",
		"\twhile (!s.empty()) {",
		"\t\txs = xs + s.top();",
		"\t\ts.pop();",
		"\t}",
		"\treturn xs;",
		"}"
	],
	"prefix": "10tox",
	"description": "10进制转x进制"
},
"x进制转10进制": {
"body": [
	"int x_to_ten_base(int n,string s){",
	"    int sum = 0;",
	"    for (char x:s){",
	"        sum *= n;",
	"        if(x>='A'&&x<='Z'){",
	"            sum += (int) (x - 'A' + 10);",
	"        }",
	"        else",
	"            sum += (int)(x - '0');",
	"        ",
	"    }",
	"    return sum;",
	"}"
],
"prefix": "xto10",
"description": "x进制转10进制"
},
"整数二分": {
"body": [
	"int bin_search(int *a, int n, int x){  //a[0]～a[n-1]是单调递增的",
	"    int l = 0, r = n;              //注意：不是 n-1",
	"    while (l < r) {",
	"        int mid = (l + r)/2; ",
	"        //int mid = (l + r) >> 1;  ",
	"        if (a[mid] >= x)  r = mid;",
	"        else    l = mid + 1;",
	"    }                   //终止于left = right",
	"    return l;       //特殊情况：a[n-1] < x时，返回n",
	"}"
],
"prefix": "erfen_int",
"description": "整数二分"
},
"实数二分": {
"body": [
	"const double eps =1e-7;        //精度。如果下面用for，可以不要eps",
	"while(r - l > eps){     //for(int i = 0; i<100; i++){",
	"    double mid = (l + r)/2;",
	"    if (check(mid)) r = mid;           //判定，然后继续二分",
	"    else            l  = mid;",
	"}"
],
"prefix": "erfen_double",
"description": "实数二分"
},
"深搜": {
	"body": [
		"int vis[10010],n;",
		"void dfs(vector<int> g,int cnt){",
		"\tif(cnt == n){",
		"\t\tfor(int i = 0 ;i < n; i++){",
		"\t\t\tcout << g[i] << \" \";",
		"\t\t}",
		"\t\tcout  <<  endl;",
		"\t\treturn;",
		"\t}",
		"\tfor(int i = 1 ; i <= n; i++){",
		"\t\tif(vis[i]) continue;//已经标记就跳过",
		"\t\tg.push_back(i);",
		"\t\tvis[i] = 1;//标记",
		"\t\tdfs(g, cnt + 1);",
		"\t\tg.pop_back();",
		"\t\tvis[i] = 0;//取消标记",
		"\t}",
		"}"
	],
	"prefix": "dfs1",
	"description": "深搜"
}
}
